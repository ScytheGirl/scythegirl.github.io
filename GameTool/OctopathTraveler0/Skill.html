<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€èƒ½æ•°æ®æŸ¥è¯¢å·¥å…·</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #1a1a2e;
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4cc9f0;
        }
        
        h1 {
            color: #4cc9f0;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.3);
        }
        
        .subtitle {
            color: #a0a0c0;
            font-size: 1.1rem;
        }
        
        .controls {
            background-color: #16213e;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }
        
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .search-box input {
            flex: 1;
            padding: 15px;
            background-color: #0f3460;
            border: 1px solid #4cc9f0;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 1rem;
            transition: border-color 0.3s;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #72efdd;
            box-shadow: 0 0 0 2px rgba(114, 239, 221, 0.2);
        }
        
        .search-btn {
            background-color: #7209b7;
            color: white;
            padding: 0 30px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .search-btn:hover {
            background-color: #5a08a3;
        }
        
        .search-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 5px solid #4cc9f0;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .data-status {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background-color: #0f3460;
            border-radius: 6px;
            border-left: 4px solid #555;
        }
        
        .status-item.loaded {
            border-left-color: #4ade80;
        }
        
        .status-item.error {
            border-left-color: #f72585;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #555;
        }
        
        .status-dot.loaded {
            background-color: #4ade80;
        }
        
        .status-dot.error {
            background-color: #f72585;
        }
        
        .status-info {
            flex: 1;
        }
        
        .status-name {
            color: #a0c4ff;
            font-weight: 500;
        }
        
        .status-text {
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        .results {
            margin-top: 20px;
        }
        
        .result-count {
            background-color: #16213e;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            font-weight: bold;
            color: #a0c4ff;
            text-align: center;
        }
        
        .skill-card {
            background-color: #16213e;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            border-left: 5px solid #4cc9f0;
        }
        
        .skill-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(76, 201, 240, 0.3);
        }
        
        .skill-name {
            font-size: 1.8rem;
            font-weight: bold;
            color: #a0c4ff;
        }
        
        .skill-id {
            background: #0f3460;
            color: #72efdd;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .skill-description {
            color: #c0c0e0;
            margin-bottom: 25px;
            font-style: italic;
            line-height: 1.8;
            padding: 15px;
            background-color: #0f3460;
            border-radius: 8px;
        }
        
        .skill-info {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0f3460;
            border-radius: 8px;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 0.9rem;
            color: #72efdd;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .info-value {
            font-weight: 600;
            color: #ffffff;
            font-size: 1.1rem;
        }
        
        .effect-details {
            margin-top: 25px;
        }
        
        .effect-header {
            font-size: 1.2rem;
            font-weight: bold;
            color: #72efdd;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(114, 239, 221, 0.3);
        }
        
        .effect-item {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #0f3460;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            border-left: 4px solid #7209b7;
        }
        
        .effect-item span {
            font-family: 'Courier New', monospace;
        }
        
        .match-rate {
            display: inline-block;
            padding: 3px 10px;
            background-color: #f72585;
            color: white;
            border-radius: 12px;
            font-size: 0.9rem;
            margin-left: 10px;
            vertical-align: middle;
            font-weight: 600;
        }
        
        .match-rate.high {
            background-color: #4ade80;
        }
        
        .match-rate.medium {
            background-color: #ffbe0b;
        }
        
        .error-message {
            background-color: rgba(247, 37, 133, 0.1);
            border: 1px solid #f72585;
            color: #f72585;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            text-align: center;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #a0a0c0;
            font-size: 1.2rem;
        }
        
        .empty-state h3 {
            margin-bottom: 10px;
            color: #a0c4ff;
        }
        
        .success-message {
            background-color: rgba(74, 222, 128, 0.1);
            border: 1px solid #4ade80;
            color: #4ade80;
            padding: 12px 20px;
            border-radius: 6px;
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: fadeIn 0.3s ease;
        }
        
        .success-message.hidden {
            display: none;
        }
        
        .success-icon {
            font-size: 1.2rem;
        }
        
        .success-text {
            flex: 1;
        }
        
        /* ä¼¤å®³è®¡ç®—å™¨æ ·å¼ */
        .damage-calculator {
            display: none;
            position: fixed;
            z-index: 1000;
            background-color: #0f3460;
            border: 2px solid #4cc9f0;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 380px;
            max-width: 90vw;
            animation: fadeIn 0.3s ease;
        }
        
        .calculator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(76, 201, 240, 0.3);
        }
        
        .calculator-title {
            color: #72efdd;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .close-calculator {
            background: none;
            border: none;
            color: #f72585;
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .calculator-form {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .form-group.row {
            flex-direction: row;
            gap: 10px;
            align-items: flex-end;
        }
        
        .form-label {
            color: #a0c4ff;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .form-input {
            padding: 8px;
            background-color: #16213e;
            border: 1px solid #4cc9f0;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.9rem;
            width: 100%;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #72efdd;
        }
        
        .form-input.small {
            width: 70px;
            text-align: center;
        }
        
        .form-input.medium {
            width: 90px;
        }
        
        .calculator-result {
            margin-top: 10px;
            padding: 10px;
            background-color: #16213e;
            border-radius: 6px;
            border-left: 4px solid #4ade80;
        }
        
        .result-title {
            color: #72efdd;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .result-value {
            color: #ffffff;
            font-size: 1.4rem;
            font-weight: bold;
            text-align: center;
            margin: 5px 0;
        }
        
        .disclaimer {
            color: #a0a0c0;
            font-size: 0.75rem;
            text-align: center;
            margin-top: 5px;
            font-style: italic;
        }
        
        .formula-link {
            color: #ffbe0b;
            text-decoration: none;
            cursor: pointer;
            border-bottom: 1px dashed #ffbe0b;
            transition: all 0.2s;
            padding: 0 2px;
        }
        
        .formula-link:hover {
            color: #ffd166;
            border-bottom: 1px solid #ffd166;
        }
        
        .calc-btn {
            background-color: #7209b7;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 5px;
        }
        
        .calc-btn:hover {
            background-color: #5a08a3;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .search-box {
                flex-direction: column;
            }
            
            .search-btn {
                padding: 15px;
            }
            
            .data-status {
                grid-template-columns: 1fr;
            }
            
            .skill-info {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .skill-header {
                flex-direction: column;
                gap: 10px;
            }
            
            .skill-id {
                align-self: flex-start;
            }
            
            .damage-calculator {
                left: 50% !important;
                transform: translateX(-50%) !important;
                top: 50% !important;
                transform: translate(-50%, -50%) !important;
            }
            
            .form-group.row {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .form-input.small,
            .form-input.medium {
                max-width: calc(77% - 6px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ“š æŠ€èƒ½æ•°æ®æŸ¥è¯¢å·¥å…·</h1>
            <p class="subtitle">æ•°æ®æå–ï¼šIriså°è‰¾è€å¸ˆ@bilibiliï¼Œç¨‹åºå¼€å‘ï¼šScytheGirl@github</p>
            <p class="subtitle">åŸºäºJSONæ•°æ®æ–‡ä»¶çš„æŠ€èƒ½æ•ˆæœæŸ¥è¯¢ç³»ç»Ÿ</p>
        </header>
        
        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="è¯·è¾“å…¥æŠ€èƒ½åç§°å…³é”®è¯ï¼ˆæ”¯æŒç©ºæ ¼åˆ†éš”å¤šä¸ªå…³é”®è¯ï¼‰æˆ–ç›´æ¥è¾“å…¥æŠ€èƒ½ID" autocomplete="off">
                <button class="search-btn" id="searchBtn" disabled>æœç´¢</button>
            </div>
            
            <div class="data-status" id="statusIndicators">
                <!-- çŠ¶æ€å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="success-message hidden" id="successMessage">
                <span class="success-icon">âœ“</span>
                <span class="success-text" id="successText">æ‰€æœ‰æ•°æ®æ–‡ä»¶å·²æˆåŠŸåŠ è½½ï¼ç°åœ¨å¯ä»¥æŸ¥è¯¢æŠ€èƒ½æ•°æ®ã€‚</span>
            </div>
            
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p>æ­£åœ¨åŠ è½½æ•°æ®ï¼Œè¯·ç¨å€™...</p>
            </div>
        </div>
        
        <div class="results" id="results">
            <!-- ç»“æœå°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
        
        <!-- ä¼¤å®³è®¡ç®—å™¨æµ®åŠ¨å±‚ -->
        <div class="damage-calculator" id="damageCalculator">
            <div class="calculator-header">
                <div class="calculator-title">ç®€æ˜“ä¼¤å®³è®¡ç®—å™¨</div>
                <button class="close-calculator" id="closeCalculator">Ã—</button>
            </div>
            <div class="calculator-form" id="calculatorForm">
                <!-- è¡¨å•å†…å®¹å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="calculator-result" id="calculatorResult" style="display: none;">
                <div class="result-title">ä¼¤å®³è®¡ç®—ç»“æœ</div>
                <div class="result-value" id="damageResult">0</div>
                <div class="disclaimer">â€» è®¡ç®—ç»“æœä»…ä¾›å‚è€ƒï¼Œå®é™…ä¼¤å®³ä»¥æ¸¸æˆå†…ä¸ºå‡†</div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€æ•°æ®å­˜å‚¨
        let gameTextSkillData = [];      // GameTextSkill.json æ•°æ®
        let skillIDData = [];            // SkillID.json æ•°æ®
        let skillAvailData = [];         // SkillAvailID.json æ•°æ®
        let ailmentTypeData = [];        // SkillAilmentType.json æ•°æ®
        let gameTextUIData = [];         // GameTextUI.json æ•°æ®
        let skillHitRateData = [];       // SkillHitRateList.json æ•°æ®
        let skillBoardData = [];         // SkillBoardData.json æ•°æ®
        let specialSkillGrowthData = []; // SpecialSkillGrowthList.json æ•°æ®
        
        // æ•°æ®æ˜ å°„è¡¨ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾
        let gameTextSkillMap = new Map();     // m_id -> æ–‡æœ¬
        let skillIDMap = new Map();           // m_id -> æŠ€èƒ½æ•°æ®
        let skillAvailMap = new Map();        // m_id -> availæ•°æ®
        let ailmentTypeMap = new Map();       // m_id -> å¼‚å¸¸çŠ¶æ€æ•°æ®
        let gameTextUIMap = new Map();        // m_id -> UIæ–‡æœ¬
        let skillHitRateMap = new Map();      // m_id -> å‘½ä¸­ç‡æ•°æ®
        let skillBoardMap = new Map();        // m_PlayerID -> æŠ€èƒ½æ¿æ•°æ®
        let specialSkillMap = new Map();      // m_SkillID -> ç‰¹æ®ŠæŠ€èƒ½æ•°æ®
        
        // è§’è‰²IDå’Œåå­—çš„å¯¹åº”å…³ç³»è¡¨
        const charaName = {
            "10101":"ç»´é˜¿ç‰¹é²","10201":"é›·æ¢…","10302":"è·¯å¾·","10402":"å¡ç³è¾¾","10503":"å‡¯è·¯æ‰æ–¯",
            "10603":"æµ·å¾·å†…","10704":"åŸƒæ–¯ä½©è·¯","10804":"æ¢…è¥¿","10905":"å¼—æ©","11005":"æˆ´è‰è’‚å¨…",
            "11106":"çš®ä¹Œæ–¯","11206":"ç½—æ‹‰å¨œ","11307":"èµ›å¢å…‹","11407":"é˜¿è•¾å¯è¥¿é›…","11508":"å¤å¾·æ¸©",
            "11608":"è¥¿å°”è","20101":"æ¬§å°”è´å…‹","20202":"ç‰¹è•¾è","20303":"æ³°é‡Œç¿","20404":"äºšèŠ¬",
            "20505":"æµ·èŒµç‰¹","20606":"æ¬§è²è‰äºš","20707":"èµ›æ‹‰æ–¯","20808":"æ™®é‡Œå§†èæ´","30103":"å·´é²æ°ç½—",
            "30207":"é˜¿æ‹‰ä¹Œå¦®","30301":"åˆ©å¤å°”","30407":"ç´¢éš†","30501":"è‰¾ç‰¹é‡Œå…‹æ–¯","30701":"éš†å¾·",
            "30808":"å¡”å›¾æ´›å…‹","40204":"æ–¯è’‚å¨…","50101":"è¨èµç‰¹æ–¯","50201":"è‰¾å°”","60107":"è‰¾æ‹‰",
            "900":"ä¸»è§’","901":"ä¸»è§’ï¼ˆå‰‘å£«ï¼‰","902":"ä¸»è§’ï¼ˆè¯å¸ˆï¼‰","903":"ä¸»è§’ï¼ˆç›—è´¼ï¼‰",
            "904":"ä¸»è§’ï¼ˆå­¦è€…ï¼‰","905":"ä¸»è§’ï¼ˆç¥å®˜ï¼‰","906":"ä¸»è§’ï¼ˆçŒäººï¼‰","907":"ä¸»è§’ï¼ˆå•†äººï¼‰",
            "908":"ä¸»è§’ï¼ˆèˆå¨˜ï¼‰"
        };
        
        // ç‰©ç†å±æ€§æ˜ å°„
        const weaponIconMapping = {
            0: 'æ— æ•ˆ', 1: 'å‰‘', 2: 'æª', 3: 'åˆƒ', 4: 'æ–§',
            5: 'å¼“', 6: 'æ–', 7: 'ä¹¦', 8: 'æ‰‡', 9: 'æ— å±æ€§'
        };
        
        // é­”æ³•å±æ€§æ˜ å°„
        const magicIconMapping = {
            0: 'æ— æ•ˆ', 1: 'ç«', 2: 'å†°', 3: 'é›·', 4: 'é£',
            5: 'å…‰', 6: 'æš—', 7: 'æ— å±æ€§'
        };
        
        // æŠ€èƒ½ç±»å‹æ˜ å°„ï¼ˆåŸºç¡€ï¼‰
        const categoryMapping = {
            0: 'ç‰¹æ®ŠæŠ€èƒ½', 1: 'ä¸»åŠ¨æŠ€èƒ½', 2: 'è¢«åŠ¨æŠ€èƒ½', 
            4: 'æ•ŒäººæŠ€èƒ½', 8: 'é“å…·æ•ˆæœ'
        };
        
        // ç›®æ ‡ç±»å‹æ˜ å°„
        const targetTypeMapping = {
            1: 'æ•Œå•ä½“', 2: 'æ•Œå…¨ä½“', 3: 'æ•Œéšæœº', 4: 'æˆ‘éšæœº',
            5: 'è‡ªå·±', 7: 'å‰å«å…¨åˆ—', 8: 'è‡ªå·±', 12: 'æˆ‘å•ä½“HP0',
            13: 'ç©ºä½', 14: 'å‘½ä¸­è€…', 20: 'æˆ‘å…¨ä½“', 30: 'æˆ‘å•ä½“',
            214: 'æˆ‘å…¨ä½“', 224: 'å‰/åå…¨åˆ—', 225: 'å‹å•ä½“', 226: 'å‰/åå…¨åˆ—'
        };

        // æ•°æ®çŠ¶æ€è·Ÿè¸ª
        const dataStatus = {
            gameTextSkill: { loaded: false, count: 0 },
            skillID: { loaded: false, count: 0 },
            skillAvail: { loaded: false, count: 0 },
            ailmentType: { loaded: false, count: 0 },
            gameTextUI: { loaded: false, count: 0 },
            skillHitRate: { loaded: false, count: 0 },
            skillBoard: { loaded: false, count: 0 },
            specialSkillGrowth: { loaded: false, count: 0 }
        };

        // DOMå…ƒç´ 
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const resultsDiv = document.getElementById('results');
        const statusIndicators = document.getElementById('statusIndicators');
        const successMessage = document.getElementById('successMessage');
        const successText = document.getElementById('successText');
        const damageCalculator = document.getElementById('damageCalculator');
        const closeCalculator = document.getElementById('closeCalculator');
        const calculatorForm = document.getElementById('calculatorForm');
        const calculatorResult = document.getElementById('calculatorResult');
        const damageResult = document.getElementById('damageResult');

        // å½“å‰è®¡ç®—å™¨ç›¸å…³çš„æ•°æ®
        let currentCalculatorData = {
            calcType: null,
            values: [],
            ratios: [],
            valueDisplay: '',
            ratioDisplay: '',
            bpLevels: 0,
            valueHasBP: false,
            ratioHasBP: false
        };
        
        // ç”¨äºè·Ÿè¸ªè®¡ç®—å™¨ä½ç½®å’Œé“¾æ¥å…ƒç´ 
        let currentLinkElement = null;
        let calculatorVisible = false;
        let lastValueBP = 0;
        let lastValueAtkP = 200;
        let lastValueDefP = 50;
        let lastValueAtkM = 200;
        let lastValueDefM = 50;
        let lastValueRatio = 1.00;

        // åˆå§‹åŒ–çŠ¶æ€æŒ‡ç¤ºå™¨
        function initStatusIndicators() {
            const statusConfigs = [
                { key: 'gameTextSkill', name: 'æŠ€èƒ½åç§°æ•°æ®', file: 'GameTextSkill.json' },
                { key: 'skillID', name: 'æŠ€èƒ½å±æ€§æ•°æ®', file: 'SkillID.json' },
                { key: 'skillAvail', name: 'æŠ€èƒ½æ•ˆæœæ•°æ®', file: 'SkillAvailID.json' },
                { key: 'ailmentType', name: 'å¼‚å¸¸çŠ¶æ€æ•°æ®', file: 'SkillAilmentType.json' },
                { key: 'gameTextUI', name: 'UIæ–‡æœ¬æ•°æ®', file: 'GameTextUI.json' },
                { key: 'skillHitRate', name: 'å‘½ä¸­ç‡æ•°æ®', file: 'SkillHitRateList.json' },
                { key: 'skillBoard', name: 'æŠ€èƒ½æ¿æ•°æ®', file: 'SkillBoardData.json' },
                { key: 'specialSkillGrowth', name: 'ç‰¹æ®ŠæŠ€èƒ½æ•°æ®', file: 'SpecialSkillGrowthList.json' }
            ];
            
            statusIndicators.innerHTML = '';
            
            statusConfigs.forEach(config => {
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                statusItem.id = `status-${config.key}`;
                
                statusItem.innerHTML = `
                    <span class="status-dot"></span>
                    <div class="status-info">
                        <div class="status-name">${config.name}</div>
                        <div class="status-text" id="status-text-${config.key}">æœªåŠ è½½</div>
                    </div>
                `;
                
                statusIndicators.appendChild(statusItem);
            });
        }

        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateStatusIndicator(key, status, message = null) {
            const statusItem = document.getElementById(`status-${key}`);
            const statusDot = statusItem.querySelector('.status-dot');
            const statusText = document.getElementById(`status-text-${key}`);
            
            // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
            statusItem.classList.remove('loaded', 'error');
            statusDot.classList.remove('loaded', 'error');
            
            if (status === 'loading') {
                statusText.textContent = message || 'åŠ è½½ä¸­...';
            } else if (status === 'loaded') {
                statusItem.classList.add('loaded');
                statusDot.classList.add('loaded');
                statusText.textContent = message || 'å·²åŠ è½½';
            } else if (status === 'error') {
                statusItem.classList.add('error');
                statusDot.classList.add('error');
                statusText.textContent = message || 'åŠ è½½å¤±è´¥';
            }
        }

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        function showSuccessMessage(message) {
            successText.textContent = message;
            successMessage.classList.remove('hidden');
            
            // 5ç§’åè‡ªåŠ¨éšè—æ¶ˆæ¯
            setTimeout(() => {
                successMessage.classList.add('hidden');
            }, 5000);
        }

        // ä»æœåŠ¡å™¨åŠ è½½JSONæ–‡ä»¶
        async function loadJsonFile(fileName) {
            try {
                const response = await fetch(fileName);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`åŠ è½½æ–‡ä»¶ ${fileName} å¤±è´¥:`, error);
                throw error;
            }
        }

        // æå–æ•°æ®æ•°ç»„ï¼ˆæ ¹æ®æä¾›çš„JSONç»“æ„ï¼‰
        function extractDataArray(data) {
            // æ ¹æ®æè¿°ï¼šdata[0]?.Properties?.Data?.m_DataList
            if (Array.isArray(data) && data.length > 0) {
                const firstItem = data[0];
                if (firstItem && firstItem.Properties && firstItem.Properties.Data && firstItem.Properties.Data.m_DataList) {
                    return firstItem.Properties.Data.m_DataList;
                }
            }
            // å¦‚æœä¸ç¬¦åˆä¸Šè¿°ç»“æ„ï¼Œç›´æ¥è¿”å›åŸæ•°æ®
            return data;
        }

        // åŠ è½½æ‰€æœ‰æ•°æ®æ–‡ä»¶
        async function loadAllData() {
            try {
                // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
                loadingIndicator.classList.add('active');
                searchBtn.disabled = true;
                successMessage.classList.add('hidden');
                
                // åˆå§‹åŒ–çŠ¶æ€æŒ‡ç¤ºå™¨
                initStatusIndicators();
                
                // æ–‡ä»¶é…ç½®åˆ—è¡¨
                const fileConfigs = [
                    { key: 'gameTextSkill', name: 'æŠ€èƒ½åç§°æ•°æ®', file: 'GameTextSkill.json' },
                    { key: 'skillID', name: 'æŠ€èƒ½å±æ€§æ•°æ®', file: 'SkillID.json' },
                    { key: 'skillAvail', name: 'æŠ€èƒ½æ•ˆæœæ•°æ®', file: 'SkillAvailID.json' },
                    { key: 'ailmentType', name: 'å¼‚å¸¸çŠ¶æ€æ•°æ®', file: 'SkillAilmentType.json' },
                    { key: 'gameTextUI', name: 'UIæ–‡æœ¬æ•°æ®', file: 'GameTextUI.json' },
                    { key: 'skillHitRate', name: 'å‘½ä¸­ç‡æ•°æ®', file: 'SkillHitRateList.json' },
                    { key: 'skillBoard', name: 'æŠ€èƒ½æ¿æ•°æ®', file: 'SkillBoardData.json' },
                    { key: 'specialSkillGrowth', name: 'ç‰¹æ®ŠæŠ€èƒ½æ•°æ®', file: 'SpecialSkillGrowthList.json' }
                ];
                
                // åŠ è½½æ‰€æœ‰æ–‡ä»¶
                for (const config of fileConfigs) {
                    try {
                        updateStatusIndicator(config.key, 'loading', 'åŠ è½½ä¸­...');
                        
                        const rawData = await loadJsonFile(config.file);
                        const extractedData = extractDataArray(rawData);
                        
                        // å­˜å‚¨åˆ°å¯¹åº”çš„æ•°æ®å˜é‡
                        switch(config.key) {
                            case 'gameTextSkill':
                                gameTextSkillData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> ç¬¬ä¸€ä¸ªéç©ºæ–‡æœ¬
                                for (const item of gameTextSkillData) {
                                    if (item.m_id && Array.isArray(item.m_gametext)) {
                                        const text = item.m_gametext.find(t => t && t.trim() !== '') || '';
                                        gameTextSkillMap.set(item.m_id, text);
                                    }
                                }
                                break;
                            case 'skillID':
                                skillIDData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> æŠ€èƒ½æ•°æ®
                                for (const skill of skillIDData) {
                                    if (skill.m_id) {
                                        skillIDMap.set(skill.m_id, skill);
                                    }
                                }
                                break;
                            case 'skillAvail':
                                skillAvailData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> availæ•°æ®
                                for (const avail of skillAvailData) {
                                    if (avail.m_id) {
                                        skillAvailMap.set(avail.m_id, avail);
                                    }
                                }
                                break;
                            case 'ailmentType':
                                ailmentTypeData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> å¼‚å¸¸çŠ¶æ€æ•°æ®
                                for (const ailment of ailmentTypeData) {
                                    if (ailment.m_id !== undefined) {
                                        ailmentTypeMap.set(ailment.m_id, ailment);
                                    }
                                }
                                break;
                            case 'gameTextUI':
                                gameTextUIData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> UIæ–‡æœ¬
                                for (const item of gameTextUIData) {
                                    if (item.m_id && Array.isArray(item.m_gametext)) {
                                        const text = item.m_gametext.find(t => t && t.trim() !== '') || '';
                                        gameTextUIMap.set(item.m_id, text);
                                    }
                                }
                                break;
                            case 'skillHitRate':
                                skillHitRateData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_id -> å‘½ä¸­ç‡æ•°æ®
                                for (const hitRate of skillHitRateData) {
                                    if (hitRate.m_id !== undefined) {
                                        skillHitRateMap.set(hitRate.m_id, hitRate);
                                    }
                                }
                                break;
                            case 'skillBoard':
                                skillBoardData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_PlayerID -> æŠ€èƒ½æ¿æ•°æ®
                                for (const board of skillBoardData) {
                                    if (board.m_PlayerID !== undefined) {
                                        skillBoardMap.set(board.m_PlayerID, board);
                                    }
                                }
                                break;
                            case 'specialSkillGrowth':
                                specialSkillGrowthData = extractedData;
                                // æ„å»ºæ˜ å°„è¡¨ï¼šm_SkillID -> ç‰¹æ®ŠæŠ€èƒ½æ•°æ®
                                for (const specialSkill of specialSkillGrowthData) {
                                    if (specialSkill.m_SkillID !== undefined) {
                                        specialSkillMap.set(specialSkill.m_SkillID, specialSkill);
                                    }
                                }
                                break;
                        }
                        
                        dataStatus[config.key].loaded = true;
                        dataStatus[config.key].count = extractedData.length;
                        updateStatusIndicator(config.key, 'loaded', `å·²åŠ è½½ (${extractedData.length} æ¡è®°å½•)`);
                        
                    } catch (error) {
                        console.error(`åŠ è½½ ${config.name} å¤±è´¥:`, error);
                        dataStatus[config.key].loaded = false;
                        updateStatusIndicator(config.key, 'error', `åŠ è½½å¤±è´¥: ${error.message}`);
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶éƒ½å·²åŠ è½½
                const essentialFilesLoaded = dataStatus.gameTextSkill.loaded && 
                                          dataStatus.skillID.loaded && 
                                          dataStatus.skillAvail.loaded;
                
                if (essentialFilesLoaded) {
                    // å¯ç”¨æŸ¥è¯¢æŒ‰é’®
                    searchBtn.disabled = false;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶åŠ è½½å¤±è´¥
                    const failedFiles = fileConfigs.filter(config => !dataStatus[config.key].loaded);
                    
                    if (failedFiles.length === 0) {
                        showSuccessMessage('æ‰€æœ‰æ•°æ®æ–‡ä»¶å·²æˆåŠŸåŠ è½½ï¼ç°åœ¨å¯ä»¥æŸ¥è¯¢æŠ€èƒ½æ•°æ®ã€‚');
                    } else {
                        showSuccessMessage(`åŸºæœ¬æ•°æ®æ–‡ä»¶å·²åŠ è½½ï¼Œä½† ${failedFiles.length} ä¸ªæ–‡ä»¶åŠ è½½å¤±è´¥ã€‚éƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™ã€‚`);
                    }
                } else {
                    showSuccessMessage('åŸºæœ¬æ•°æ®æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œæ— æ³•è¿›è¡ŒæŸ¥è¯¢ã€‚è¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„å¹¶é‡è¯•ã€‚');
                }
                
            } catch (error) {
                console.error('åŠ è½½æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯:', error);
                showSuccessMessage('åŠ è½½æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
            } finally {
                // éšè—åŠ è½½æŒ‡ç¤ºå™¨
                loadingIndicator.classList.remove('active');
            }
        }

        // æœç´¢æŠ€èƒ½
        async function searchSkills() {
            const keywords = searchInput.value.trim();
            if (!keywords) {
                showError('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
                return;
            }
            
            // ç¦ç”¨æœç´¢æŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½ä¸­
            searchBtn.disabled = true;
            searchBtn.textContent = 'æœç´¢ä¸­...';
            resultsDiv.innerHTML = '<div class="loading active"><div class="spinner"></div><p>æ­£åœ¨æœç´¢ï¼Œè¯·ç¨å€™...</p></div>';
            
            try {
                // å»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…UIé˜»å¡
                setTimeout(() => {
                    const results = performSearch(keywords);
                    displayResults(results);
                    searchBtn.disabled = false;
                    searchBtn.textContent = 'æœç´¢';
                }, 50);
                
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                showError('æœç´¢å¤±è´¥: ' + error.message);
                searchBtn.disabled = false;
                searchBtn.textContent = 'æœç´¢';
            }
        }

        // æ‰§è¡Œæœç´¢é€»è¾‘
        function performSearch(keywords) {
            // åˆ†å‰²å…³é”®è¯
            const keywordList = keywords.split(/\s+/).filter(k => k.length > 0);
            
            if (keywordList.length === 0) {
                return [];
            }
            
            let searchById = 0;
            if (keywordList.length === 1) {
                const matched = keywordList[0].match(/^(\d+)$/);
                if (matched) {
                    searchById = parseInt(matched[0]);
                }
            }
            
            // åœ¨GameTextSkillä¸­åŒ¹é…æ–‡æœ¬
            const matchedTextIds = [];
            const matchScores = new Map(); // m_id -> åŒ¹é…åº¦
            
            for (const [id, text] of gameTextSkillMap.entries()) {
                let matchCount = 0;
                
                for (const keyword of keywordList) {
                    if (text.includes(keyword)) {
                        matchCount++;
                    }
                }
                
                const matchRate = matchCount / keywordList.length;
                if (matchRate >= 0.75) {
                    matchedTextIds.push(id);
                    matchScores.set(id, matchRate);
                }
            }
            
            // åœ¨SkillIDä¸­æŸ¥æ‰¾åŒ¹é…çš„æŠ€èƒ½
            const matchedSkills = [];
            
            for (const skill of skillIDData) {
                if (!skill.m_id) continue;
                
                // æ£€æŸ¥m_Nameæˆ–m_Detailæ˜¯å¦åœ¨åŒ¹é…çš„æ–‡æœ¬IDä¸­
                const nameMatch = matchedTextIds.includes(skill.m_Name);
                const detailMatch = matchedTextIds.includes(skill.m_Detail);
                
                if (nameMatch || detailMatch) {
                    // è·å–åŒ¹é…åº¦ï¼ˆå–æœ€å¤§å€¼ï¼‰
                    const nameScore = matchScores.get(skill.m_Name) || 0;
                    const detailScore = matchScores.get(skill.m_Detail) || 0;
                    const score = Math.max(nameScore, detailScore);
                    
                    matchedSkills.push({
                        skill,
                        matchScore: score,
                        matchType: nameMatch ? 'åç§°' : 'æè¿°'
                    });
                // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‰IDåŒ¹é…çš„æƒ…å†µ
                } else if (searchById && skill.m_id === searchById) {
                    matchedSkills.push({
                        skill,
                        matchScore: 1,
                        matchType: "ID"
                    });
                }
            }
            
            // æŒ‰åŒ¹é…åº¦é™åºæ’åº
            matchedSkills.sort((a, b) => b.matchScore - a.matchScore);
            
            return matchedSkills;
        }

        // æŸ¥æ‰¾æŠ€èƒ½å¯¹åº”çš„è§’è‰²ä¿¡æ¯
        function findSkillOwner(skillId, category, spCost) {
            const result = {
                owner: null,
                canEssential: null,
                isSpecialSkill: false,
                isNPC: false,
                isEssentialSkill: false
            };
            
            // åªæœ‰ç±»åˆ«ä¸º1æˆ–2çš„æŠ€èƒ½æ‰æŸ¥æ‰¾
            if (category !== 1 && category !== 2) {
                return result;
            }
            
            // å…ˆæŸ¥æ‰¾SkillBoardData.json
            for (const [playerId, boardData] of skillBoardMap.entries()) {
                if (category === 1) {
                    // ä¸»åŠ¨æŠ€èƒ½åœ¨m_SkillIDä¸­æŸ¥æ‰¾
                    const skillIndex = boardData.m_SkillID.indexOf(skillId);
                    if (skillIndex !== -1) {
                        result.owner = charaName[playerId] || `è§’è‰²${playerId}`;
                        result.canEssential = boardData.m_CanNotEssential && boardData.m_CanNotEssential[skillIndex] === false;
                        return result;
                    }
                } else if (category === 2) {
                    // è¢«åŠ¨æŠ€èƒ½åœ¨m_SupportSkillIDä¸­æŸ¥æ‰¾
                    const skillIndex = boardData.m_SupportSkillID.indexOf(skillId);
                    if (skillIndex !== -1) {
                        result.owner = charaName[playerId] || `è§’è‰²${playerId}`;
                        result.canEssential = boardData.m_CanNotSupportEssential && boardData.m_CanNotSupportEssential[skillIndex] === false;
                        return result;
                    }
                }
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå†æŸ¥æ‰¾SpecialSkillGrowthList.json
            const specialSkillData = specialSkillMap.get(skillId);
            if (specialSkillData) {
                const specialSkillId = specialSkillData.m_SpecialSkillID;
                result.owner = charaName[specialSkillId] || `è§’è‰²${specialSkillId}`;
                result.isSpecialSkill = true;
                result.canEssential = false; // å¿…æ€æŠ€èƒ½æ— æ³•ç²¾ç²¹åŒ–
                return result;
            }
            
            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°
            if (category === 1 && spCost === 0) {
                result.isNPC = true;
            } else {
                result.isEssentialSkill = true;
            }
            
            return result;
        }

        // æå–æŠ€èƒ½åŸºæœ¬ä¿¡æ¯
        function extractSkillInfo(skill) {
            const info = {
                name: gameTextSkillMap.get(skill.m_Name) || 'æœªçŸ¥',
                description: gameTextSkillMap.get(skill.m_Detail) || '',
                attributes: '-',
                category: categoryMapping[skill.m_Category] || 'æœªçŸ¥',
                originalCategory: skill.m_Category,
                spCost: skill.m_RequireValue || 0,
                ownerInfo: null,
                displayName: ''
            };
            
            // ç»„åˆç‰©ç†å’Œé­”æ³•å±æ€§
            const weaponAttr = weaponIconMapping[skill.m_WeaponIconType];
            const magicAttr = magicIconMapping[skill.m_MagicIconType];
            
            if (weaponAttr !== 'æ— æ•ˆ' && magicAttr !== 'æ— æ•ˆ') {
                info.attributes = `${weaponAttr}+${magicAttr}`;
            } else if (weaponAttr !== 'æ— æ•ˆ') {
                info.attributes = weaponAttr;
            } else if (magicAttr !== 'æ— æ•ˆ') {
                info.attributes = magicAttr;
            }
            
            // é¢å¤–ä¿¡æ¯
            if (skill.m_ReChargeTrun && skill.m_ReChargeTrun > 0) {
                info.coolDown = skill.m_ReChargeTrun;
            }
            
            // è·å–Availæ•°æ®ï¼ˆç”¨äºè·å–æš´å‡»è¡¥æ­£å’Œç ´ç›¾å±‚æ•°ï¼‰
            const availIds = (skill.m_Avails || []).filter(id => id > 0);
            if (availIds.length > 0) {
                const firstAvail = skillAvailMap.get(availIds[0]);
                if (firstAvail) {
                    info.critRate = firstAvail.m_CriticalRatio;
                    info.shieldDamage = firstAvail.m_ShieldDamage;
                }
            }
            
            // æŸ¥æ‰¾æŠ€èƒ½æ‰€æœ‰è€…ä¿¡æ¯
            if (skill.m_Category === 1 || skill.m_Category === 2) {
                info.ownerInfo = findSkillOwner(skill.m_id, skill.m_Category, info.spCost);
                
                // æ ¹æ®æ‰€æœ‰è€…ä¿¡æ¯ä¿®æ”¹æŠ€èƒ½åç§°å’Œç±»å‹
                if (info.ownerInfo.owner) {
                    info.displayName = `${info.name}ã€${info.ownerInfo.owner}ã€‘`;
                    
                    if (info.ownerInfo.isSpecialSkill) {
                        info.category = 'å¿…æ€æŠ€èƒ½';
                    }
                } else {
                    info.displayName = info.name;
                    
                    if (info.ownerInfo.isNPC) {
                        info.category = 'NPCæŠ€èƒ½';
                    } else if (info.ownerInfo.isEssentialSkill) {
                        if (skill.m_Name === 0) {
                            info.category = 'è£…å¤‡é™„å¸¦æŠ€èƒ½';
                        } else if (skill.m_Category === 1) {
                            info.category = 'ä¸»åŠ¨æŠ€èƒ½ï¼ˆç²¾ç²¹ï¼‰';
                        } else if (skill.m_Category === 2) {
                            info.category = 'è¢«åŠ¨æŠ€èƒ½ï¼ˆç²¾ç²¹ï¼‰';
                        }
                    }
                }
            } else {
                info.displayName = info.name;
            }
            
            return info;
        }

        // è·å–çŠ¶æ€æ–‡æœ¬ï¼ˆç”¨äºm_AddAilmentå’Œm_SubAilmentï¼‰
        function getAilmentText(ailmentIds) {
            const ailments = [];
            
            for (const ailmentId of ailmentIds) {
                if (!ailmentId || ailmentId === 0) continue;
                
                const ailment = ailmentTypeMap.get(ailmentId);
                if (ailment) {
                    if (ailment.m_TextID && ailment.m_TextID > 0) {
                        const text = gameTextUIMap.get(ailment.m_TextID);
                        if (text) {
                            ailments.push(text);
                        } else {
                            ailments.push(`<${ailment.m_Label || 'æœªçŸ¥'}>`);
                        }
                    } else {
                        ailments.push(`<${ailment.m_Label || 'æœªçŸ¥'}>`);
                    }
                }
            }
            
            return ailments.join('/');
        }

        // ç”ŸæˆæŠ€èƒ½æ•ˆæœæè¿°
        function generateSkillEffects(skill) {
            const effects = [];
            const availIds = (skill.m_Avails || []).filter(id => id > 0);
            
            // è®¡ç®—é‡å¤æ¬¡æ•°
            const availCounts = new Map();
            for (const id of availIds) {
                availCounts.set(id, (availCounts.get(id) || 0) + 1);
            }
            
            // å¤„ç†æ¯ä¸ªå”¯ä¸€çš„avail
            for (const [availId, count] of availCounts) {
                const avail = skillAvailMap.get(availId);
                if (!avail) continue;
                
                const effect = generateSingleEffect(avail, count);
                if (effect) {
                    effects.push(effect);
                }
            }
            
            if (effects.length === 0) {
                effects.push('(æŠ€èƒ½æ•ˆæœè¯·å‚è§æè¿°)');
            }
            
            return effects;
        }

        // å¤„ç†m_HitTypesæ•°ç»„
        function processHitTypes(hitTypes) {
            if (!hitTypes || !Array.isArray(hitTypes)) {
                return [];
            }
            
            let effectiveHitTypes = [];
            
            if (hitTypes.length > 0) {
                if (hitTypes[1] === 0) {
                    effectiveHitTypes = [hitTypes[0]];
                } else {
                    effectiveHitTypes = hitTypes.filter(v => v !== 0);
                }
            }
            
            return effectiveHitTypes;
        }

        // è·å–å‘½ä¸­ç‡ä¿¡æ¯
        function getHitRateInfo(hitTypeId) {
            if (!hitTypeId || hitTypeId === 0 || !skillHitRateMap.has(hitTypeId)) {
                return null;
            }
            
            const hitRateData = skillHitRateMap.get(hitTypeId);
            if (!hitRateData) {
                return null;
            }
            
            // æå–å‘½ä¸­ç‡æ•°ç»„ä¸­çš„éé›¶å€¼
            const hitRates = (hitRateData.m_HitRates || []).filter(rate => rate !== 0);
            
            // è®¡ç®—100%å‘½ä¸­çš„ä¸ªæ•°
            const guaranteedHits = hitRates.filter(rate => rate === 100).length;
            
            return {
                minCount: hitRateData.m_MinCount || 1,
                totalHits: hitRates.length,
                guaranteedHits: guaranteedHits,
                hitRates: hitRates
            };
        }

        // æ ¼å¼åŒ–æ¬¡æ•°æ˜¾ç¤ºï¼ˆè€ƒè™‘å‘½ä¸­ç‡ä¿¡æ¯ï¼‰
        function formatCountDisplay(baseCount, hitRateInfo) {
            if (!hitRateInfo) {
                return baseCount || 1;
            }
            
            const minTotal = baseCount * hitRateInfo.minCount;
            const maxTotal = baseCount * hitRateInfo.totalHits;
            const guaranteedTotal = baseCount * hitRateInfo.guaranteedHits;
            
            if (minTotal === maxTotal) {
                if (guaranteedTotal === minTotal || hitRateInfo.minCount === 1) {
                    return `${minTotal}`;
                } else {
                    return `${minTotal}ï¼ˆå¿…ä¸­${guaranteedTotal}ï¼‰`;
                }
            } else {
                if (guaranteedTotal > 0) {
                    return `${minTotal}-${maxTotal}ï¼ˆå¿…ä¸­${guaranteedTotal}ï¼‰`;
                } else {
                    return `${minTotal}-${maxTotal}`;
                }
            }
        }

        // ç®€åŒ–ä¼¤å®³å…¬å¼æ˜¾ç¤º
        function simplifyDamageFormula(calcType, valueDisplay, ratioDisplay) {
            if (calcType !== 1 && calcType !== 2) {
                return generateDamageFormula(calcType, valueDisplay, ratioDisplay);
            }
            
            let simplified = '';
            
            // è®¡ç®—value/100
            const valueExpr = simplifyValueExpression(valueDisplay, 0.01);
            
            // è®¡ç®—ratio/100
            const ratioExpr = simplifyValueExpression(ratioDisplay, 0.01);
            
            if (calcType === 1) {
                simplified = `(ç‰©æ”»Ã—${valueExpr}-ç‰©é˜²Ã·2)`;
            } else if (calcType === 2) {
                // æ ¹æ®valueçš„æ­£è´Ÿåˆ¤æ–­
                let isDamage = false;
                if (typeof valueDisplay === 'number') {
                    isDamage = valueDisplay < 0;
                } else if (typeof valueDisplay === 'string') {
                    // å°è¯•è§£æç¬¬ä¸€ä¸ªæ•°å€¼
                    const match = valueDisplay.match(/-?\d+(\.\d+)?/);
                    if (match) {
                        isDamage = parseFloat(match[0]) < 0;
                    }
                }
                
                if (isDamage) {
                    simplified = `(é­”æ”»Ã—${valueExpr}-é­”é˜²Ã·2)`;
                } else {
                    simplified = `é­”é˜²`;
                }
            }
            
            // æ¢å¤ç±»æŠ€èƒ½ï¼ŒæŠŠvalueå’Œratioç›¸ä¹˜
            if (simplified === 'é­”é˜²') {
                let totalExpr = `${valueExpr}Ã—${ratioExpr}`;
                if (typeof valueDisplay === 'number') {
                    totalExpr = simplifyValueExpression(ratioDisplay, valueDisplay / 100 / 100);
                } else if (typeof ratioDisplay === 'number') {
                    totalExpr = simplifyValueExpression(valueDisplay, ratioDisplay / 100 / 100);
                }
                // å¦‚æœæ€»å€ç‡ä¸æ˜¯1ï¼Œåˆ™ä¹˜ä»¥æ€»å€ç‡
                if (totalExpr !== '1' && totalExpr !== 1 ) {
                    simplified += `Ã—${totalExpr}`;
                }
            } else {
                // éæ¢å¤ç±»æŠ€èƒ½ï¼Œå¦‚æœratioä¸æ˜¯1ï¼Œåˆ™ä¹˜ä»¥ratio
                if (ratioExpr !== '1' && ratioExpr !== 1) {
                    simplified += `Ã—${ratioExpr}`;
                }
            }
            
            // æ·»åŠ å…¶ä»–å€ç‡
            simplified += 'Ã—å…¶ä»–å€ç‡';
            
            return simplified;
        }

        // ç®€åŒ–æ•°å€¼è¡¨è¾¾å¼ - ä¿®å¤ï¼šæ­£ç¡®å¤„ç†è´Ÿæ•°å’Œç™¾åˆ†æ¯”
        function simplifyValueExpression(displayValue, multiplier) {
            if (typeof displayValue === 'number') {
                // å–ç»å¯¹å€¼ï¼Œå› ä¸ºä¼¤å®³å…¬å¼ä¸­valueæ˜¯ç»å¯¹å€¼
                const absValue = Math.abs(displayValue);
                const result = multiplier * absValue;
                // ä¿ç•™æœ€å¤š3ä½å°æ•°ï¼Œå»æ‰æœ«å°¾çš„0
                return result.toFixed(3).replace(/\.?0+$/, '');
            } else if (typeof displayValue === 'string') {
                // å¤„ç†[+diff/BP]æ ¼å¼
                if (displayValue.includes('[+')) {
                    const parts = displayValue.split('[+');
                    const base = Math.abs(parseFloat(parts[0])); // å–ç»å¯¹å€¼
                    const diffPart = parts[1].replace('/BP]', '');
                    const diff = parseFloat(diffPart);
                    
                    const baseResult = multiplier * base;
                    const diffResult = multiplier * Math.abs(diff); // å–ç»å¯¹å€¼
                    
                    return `${baseResult.toFixed(3).replace(/\.?0+$/, '')}[+${diffResult.toFixed(3).replace(/\.?0+$/, '')}/BP]`;
                }
                // å¤„ç†æ•°ç»„æ ¼å¼ [a/b/c]
                else if (displayValue.startsWith('[') && displayValue.endsWith(']')) {
                    const values = displayValue.slice(1, -1).split('/').map(v => Math.abs(parseFloat(v))); // å–ç»å¯¹å€¼
                    const results = values.map(v => {
                        const result = multiplier * v;
                        return result.toFixed(3).replace(/\.?0+$/, '');
                    });
                    return `[${results.join('/')}]`;
                }
                // ç›´æ¥æ•°å€¼
                else {
                    const value = parseFloat(displayValue);
                    if (!isNaN(value)) {
                        const result = multiplier * Math.abs(value); // å–ç»å¯¹å€¼
                        return result.toFixed(3).replace(/\.?0+$/, '');
                    }
                }
            }
            
            return displayValue;
        }

        // è·å–ä¼¤å®³å…¬å¼åŸå§‹æ•°æ®ï¼ˆç”¨äºè®¡ç®—å™¨ï¼‰- ä¿®å¤ï¼šæ­£ç¡®åˆ¤æ–­BPç­‰çº§
        function getDamageFormulaData(calcType, valueDisplay, ratioDisplay) {
            const data = {
                calcType: calcType,
                values: [],
                ratios: [],
                valueDisplay: valueDisplay,
                ratioDisplay: ratioDisplay,
                bpLevels: 0,
                valueHasBP: false,
                ratioHasBP: false
            };
            
            // åˆ¤æ–­valueæ˜¯å¦ä¸BPç›¸å…³
            data.valueHasBP = typeof valueDisplay === 'string' && 
                (valueDisplay.includes('[+') || 
                 (valueDisplay.startsWith('[') && valueDisplay.endsWith(']') && valueDisplay.split('/').length > 1));
            
            // åˆ¤æ–­ratioæ˜¯å¦ä¸BPç›¸å…³
            data.ratioHasBP = typeof ratioDisplay === 'string' && 
                (ratioDisplay.includes('[+') || 
                 (ratioDisplay.startsWith('[') && ratioDisplay.endsWith(']') && ratioDisplay.split('/').length > 1));
            
            // æå–valuesæ•°ç»„
            if (typeof valueDisplay === 'number') {
                data.values = [Math.abs(valueDisplay)]; // å–ç»å¯¹å€¼
            } else if (typeof valueDisplay === 'string') {
                // å¤„ç†[+diff/BP]æ ¼å¼
                if (valueDisplay.includes('[+')) {
                    const parts = valueDisplay.split('[+');
                    const base = Math.abs(parseFloat(parts[0])); // å–ç»å¯¹å€¼
                    const diffPart = parts[1].replace('/BP]', '');
                    const diff = Math.abs(parseFloat(diffPart)); // å–ç»å¯¹å€¼
                    
                    data.values = [base, base + diff, base + 2*diff, base + 3*diff];
                }
                // å¤„ç†æ•°ç»„æ ¼å¼ [a/b/c]
                else if (valueDisplay.startsWith('[') && valueDisplay.endsWith(']')) {
                    const values = valueDisplay.slice(1, -1).split('/').map(v => Math.abs(parseFloat(v))); // å–ç»å¯¹å€¼
                    data.values = values;
                }
                // ç›´æ¥æ•°å€¼
                else {
                    const value = parseFloat(valueDisplay);
                    if (!isNaN(value)) {
                        data.values = [Math.abs(value)]; // å–ç»å¯¹å€¼
                    }
                }
            }
            
            // æå–ratiosæ•°ç»„
            if (typeof ratioDisplay === 'number') {
                data.ratios = [ratioDisplay];
            } else if (typeof ratioDisplay === 'string') {
                // å¤„ç†[+diff/BP]æ ¼å¼
                if (ratioDisplay.includes('[+')) {
                    const parts = ratioDisplay.split('[+');
                    const base = parseFloat(parts[0]);
                    const diffPart = parts[1].replace('/BP]', '');
                    const diff = parseFloat(diffPart);
                    
                    data.ratios = [base, base + diff, base + 2*diff, base + 3*diff];
                }
                // å¤„ç†æ•°ç»„æ ¼å¼ [a/b/c]
                else if (ratioDisplay.startsWith('[') && ratioDisplay.endsWith(']')) {
                    const values = ratioDisplay.slice(1, -1).split('/').map(v => parseFloat(v));
                    data.ratios = values;
                }
                // ç›´æ¥æ•°å€¼
                else {
                    const value = parseFloat(ratioDisplay);
                    if (!isNaN(value)) {
                        data.ratios = [value];
                    }
                }
            }
            
            // ç¡®å®šBPç­‰çº§æ•°ï¼šå–valueså’Œratiosä¸­è¾ƒå¤§çš„æ•°ç»„é•¿åº¦å‡1
            const maxValues = data.values.length;
            const maxRatios = data.ratios.length;
            data.bpLevels = Math.max(maxValues, maxRatios) - 1;
            
            return data;
        }

        // æ˜¾ç¤ºä¼¤å®³è®¡ç®—å™¨ - ä¿®å¤ï¼šæ­£ç¡®æ˜¾ç¤ºBPé€‰æ‹©ï¼Œä¼˜åŒ–å®šä½
        function showDamageCalculator(calcType, valueDisplay, ratioDisplay, element) {
            currentLinkElement = element;
            currentCalculatorData = getDamageFormulaData(calcType, valueDisplay, ratioDisplay);
            
            
            // ç”Ÿæˆè®¡ç®—å™¨è¡¨å•
            let formHTML = '';
            
            
            // åˆ¤æ–­æ˜¯ä¼¤å®³è¿˜æ˜¯å›å¤
            let isDamage = false;
            if (calcType === 1) {
                isDamage = true;
            } else if (calcType === 2) {
                // åˆ¤æ–­æ˜¯ä¼¤å®³è¿˜æ˜¯å›å¤
                if (typeof valueDisplay === 'number') {
                    isDamage = valueDisplay < 0;
                } else if (typeof valueDisplay === 'string') {
                    // å°è¯•è§£æç¬¬ä¸€ä¸ªæ•°å€¼
                    const match = valueDisplay.match(/-?\d+(\.\d+)?/);
                    if (match) {
                        isDamage = parseFloat(match[0]) < 0;
                    }
                }
            }
            
            // åˆ›å»ºä¸‰åˆ—å¸ƒå±€çš„è¡¨å•
            formHTML += `<div class="form-group row">`;
            
            if (calcType === 1) {
                formHTML += `
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                        <label class="form-label">ç‰©æ”»</label>
                        <input type="number" id="atkP" class="form-input small" min="1" max="999" value="${lastValueAtkP}">
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                        <label class="form-label">ç‰©é˜²</label>
                        <input type="number" id="defP" class="form-input small" min="1" max="999" value="${lastValueDefP}">
                    </div>
                `;
            } else if (calcType === 2) {
                if (isDamage) {
                    formHTML += `
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                            <label class="form-label">é­”æ”»</label>
                            <input type="number" id="atkM" class="form-input small" min="1" max="999" value="${lastValueAtkM}">
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                            <label class="form-label">é­”é˜²</label>
                            <input type="number" id="defM" class="form-input small" min="1" max="999" value="${lastValueDefM}">
                        </div>
                    `;
                } else {
                    formHTML += `
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                            <label class="form-label">é­”é˜²</label>
                            <input type="number" id="defM" class="form-input small" min="1" max="999" value="${lastValueDefM}">
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px; visibility: hidden;">
                            <label class="form-label">å ä½</label>
                            <div class="form-input small"></div>
                        </div>
                    `;
                }
            }
            
            // æ·»åŠ BPé€‰æ‹©ï¼ˆå¦‚æœvalueæˆ–ratioä¸BPç›¸å…³ï¼‰
            if (currentCalculatorData.valueHasBP || currentCalculatorData.ratioHasBP) {
                formHTML += `
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                        <label class="form-label">æ¶ˆè´¹BP</label>
                        <select id="bpLevel" class="form-input small">
                            ${Array.from({length: currentCalculatorData.bpLevels + 1}, (_, i) => 
                                `<option value="${i}"${i === lastValueBP ? " selected" : ""}>${i}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            } else {
                formHTML += `
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
                        <label class="form-label">BPç­‰çº§</label>
                        <input type="text" id="bpLevel" class="form-input small" value="0" readonly style="background-color: #0f3460;">
                    </div>
                `;
            }
            
            formHTML += `</div>`;
            
            // æ·»åŠ å…¶ä»–å€ç‡
            formHTML += `
                <div class="form-group">
                    <label class="form-label">å…¶ä»–å€ç‡ (0.01-999.99)</label>
                    <input type="number" id="otherMultiplier" class="form-input" min="0.01" max="999.99" step="0.01" value="${lastValueRatio}">
                </div>
                <button type="button" id="calculateDamage" class="calc-btn">è®¡ç®—ä¼¤å®³</button>
            `;
            
            calculatorForm.innerHTML = formHTML;
            calculatorResult.style.display = 'none';
            
            // æ˜¾ç¤ºè®¡ç®—å™¨
            damageCalculator.style.display = 'block';
            calculatorVisible = true;

            
            // ç»‘å®šè®¡ç®—äº‹ä»¶
            document.getElementById('calculateDamage').addEventListener('click', calculateDamage);
            
            // ç»‘å®šè¾“å…¥å˜åŒ–äº‹ä»¶
            calculatorForm.querySelectorAll('input, select').forEach(input => {
                input.addEventListener('input', calculateDamage);
                input.addEventListener('change', calculateDamage);
            });
            
            // åˆå§‹è®¡ç®—
            calculateDamage();

            // å®šä½è®¡ç®—å™¨
            positionCalculator(element);

        }

        // å®šä½è®¡ç®—å™¨ - ä¿®å¤ï¼šå§‹ç»ˆè·Ÿéšé“¾æ¥ï¼Œä¸è¿›è¡Œè§†å£è¾¹ç•Œæ£€æŸ¥
        function positionCalculator(element) {
            if (!element) return;
            
            // è·å–é“¾æ¥çš„ä½ç½®
            const rect = element.parentElement.getBoundingClientRect();
            
            // å°†è®¡ç®—å™¨å®šä½åœ¨å³ä¸‹è§’å¯¹é½
            const top = rect.bottom - damageCalculator.clientHeight;
            const left = rect.right - damageCalculator.clientWidth;
            
            // åº”ç”¨ä½ç½®ï¼ˆä¸æ£€æŸ¥æ˜¯å¦åœ¨è§†å£å†…ï¼‰
            damageCalculator.style.top = `${top}px`;
            damageCalculator.style.left = `${left}px`;
        }

        // æ›´æ–°è®¡ç®—å™¨ä½ç½®ï¼ˆç”¨äºæ»šåŠ¨æ—¶ï¼‰
        function updateCalculatorPosition() {
            if (!calculatorVisible || !currentLinkElement) return;
            
            // æ£€æŸ¥é“¾æ¥å…ƒç´ æ˜¯å¦è¿˜åœ¨DOMä¸­
            if (!document.body.contains(currentLinkElement)) {
                // å¦‚æœé“¾æ¥å·²ç»ä¸å­˜åœ¨ï¼Œå…³é—­è®¡ç®—å™¨
                damageCalculator.style.display = 'none';
                calculatorVisible = false;
                return;
            }
            
            // é‡æ–°å®šä½è®¡ç®—å™¨
            positionCalculator(currentLinkElement);
        }

        // è®¡ç®—ä¼¤å®³
        function calculateDamage() {
            try {
                const bpLevel = parseInt(document.getElementById('bpLevel').value) || 0;
                
                if (document.getElementById('bpLevel').tagName === 'SELECT') {
                    lastValueBP = bpLevel;
                }
                
                // è·å–valueså’Œratioså¯¹åº”BPç­‰çº§çš„å€¼
                const valueIndex = Math.min(bpLevel, currentCalculatorData.values.length - 1);
                const ratioIndex = Math.min(bpLevel, currentCalculatorData.ratios.length - 1);
                
                const value = currentCalculatorData.values[valueIndex];
                const ratio = currentCalculatorData.ratios[ratioIndex] / 100; // ratioæ˜¯ç™¾åˆ†æ¯”
                const otherMultiplier = parseFloat(document.getElementById('otherMultiplier').value) || 1;
                
                let damage = 0;
                lastValueRatio = otherMultiplier;
                
                if (currentCalculatorData.calcType === 1) {
                    const atkP = parseFloat(document.getElementById('atkP').value) || 0;
                    const defP = parseFloat(document.getElementById('defP').value) || 0;
                    lastValueAtkP = atkP;
                    lastValueDefP = defP;
                    damage = (atkP * value / 100 - defP / 2) * ratio * otherMultiplier;
                } else if (currentCalculatorData.calcType === 2) {
                    // åˆ¤æ–­æ˜¯ä¼¤å®³è¿˜æ˜¯å›å¤
                    const isDamage = typeof currentCalculatorData.valueDisplay === 'string' ? 
                        currentCalculatorData.valueDisplay.includes('-') : 
                        currentCalculatorData.valueDisplay < 0;
                    
                    if (isDamage) {
                        const atkM = parseFloat(document.getElementById('atkM').value) || 0;
                        const defM = parseFloat(document.getElementById('defM').value) || 0;
                        lastValueAtkM = atkM;
                        lastValueDefM = defM;
                        damage = (atkM * value / 100 - defM / 2) * ratio * otherMultiplier;
                    } else {
                        const defM = parseFloat(document.getElementById('defM').value) || 0;
                        lastValueDefM = defM;
                        damage = (defM * value / 100) * ratio * otherMultiplier;
                    }
                }
                
                // ç¡®ä¿ä¼¤å®³éè´Ÿ
                damage = Math.max(1, damage);
                
                // è®¡ç®—æµ®åŠ¨èŒƒå›´ï¼ˆ98%~102%ï¼‰
                const minDamage = Math.ceil(damage * 0.98);
                const maxDamage = Math.floor(damage * 1.02);
                
                // æ˜¾ç¤ºç»“æœ
                damageResult.textContent = `${minDamage}~${maxDamage}`;
                calculatorResult.style.display = 'block';
                
            } catch (error) {
                console.error('è®¡ç®—ä¼¤å®³æ—¶å‡ºé”™:', error);
                damageResult.textContent = 'è®¡ç®—é”™è¯¯';
                calculatorResult.style.display = 'block';
            }
        }

        // ç”Ÿæˆå•ä¸ªæ•ˆæœæè¿° - ä¿®å¤ï¼šåªåœ¨calcType=1æˆ–2æ—¶ç”Ÿæˆå¯ç‚¹å‡»é“¾æ¥
        function generateSingleEffect(avail, count) {
            // å¤„ç†ç›®æ ‡ç±»å‹
            const target = targetTypeMapping[avail.m_TargetType] || `æœªçŸ¥ç›®æ ‡(${avail.m_TargetType})`;
            
            // å¤„ç†m_Valuesæ•°ç»„
            const values = (avail.m_Values || []).filter(v => v !== undefined);
            let effectiveValues = [];
            
            if (values.length > 0) {
                if (values[1] === 0) {
                    effectiveValues = [values[0]];
                } else {
                    effectiveValues = values.filter(v => v !== 0);
                }
            }
            
            // å¤„ç†m_AddAilment
            const addAilmentIds = (avail.m_AddAilment || []).filter(id => id > 0);
            const addAilmentText = getAilmentText(addAilmentIds);
            const addAilmentExtras = (avail.m_ValueAilment || []).filter(id => id > 0);
            let addAilmentExtraInfo = "";
            if (addAilmentExtras.length > 0) {
                switch (addAilmentExtras[0]) {
                    case 1:
                        addAilmentExtraInfo = "ï¼ˆ+1å±‚ï¼‰";
                        break;
                    case 2:
                        addAilmentExtraInfo = "ï¼ˆ+2å±‚ï¼‰";
                        break;
                    case 30:
                        addAilmentExtraInfo = "ï¼ˆ-2å±‚ï¼‰";
                        break;
                    case 31:
                        addAilmentExtraInfo = "ï¼ˆ-1å±‚ï¼‰";
                        break;
                }
            }
            if (avail.m_AddAilmentPick > 0) {
                addAilmentExtraInfo += `ï¼ˆéšæœº${avail.m_AddAilmentPick}é¡¹ï¼‰`;
            }
            
            // å¤„ç†m_SubAilment
            const subAilmentIds = (avail.m_SubAilment || []).filter(id => id > 0);
            const subAilmentText = getAilmentText(subAilmentIds);
            const subAilmentExtraInfo = avail.m_SubAilmentPick > 0 ? `ï¼ˆéšæœº${avail.m_SubAilmentPick}é¡¹ï¼‰` : "";
            
            // å¤„ç†m_Turns
            const turns = (avail.m_Turns || []).filter(t => t !== undefined && t !== 0);
            let effectiveTurns = [];
            
            if (turns.length > 0) {
                if (turns[1] === 0) {
                    effectiveTurns = [turns[0]];
                } else {
                    effectiveTurns = turns.filter(t => t !== 0);
                }
            }
            
            // å¤„ç†m_SkillRatios
            const ratios = avail.m_SkillRatios || [];
            let effectiveRatios = [];
            
            if (ratios.length > 0) {
                if (effectiveValues.length === 1) {
                    effectiveRatios = [ratios[0]];
                } else {
                    effectiveRatios = ratios.slice(0, effectiveValues.length);
                }
            }
            
            // å¤„ç†m_Counts
            const counts = avail.m_Counts || [];
            let effectiveCounts = [];
            
            if (counts.length > 0) {
                if (counts[1] === 0) {
                    effectiveCounts = [counts[0]];
                } else {
                    effectiveCounts = counts.filter(c => c !== 0);
                }
            }
            
            // å¤„ç†m_HitTypes
            const hitTypes = processHitTypes(avail.m_HitTypes);
            let hitRateInfo = null;
            let hitRatePrefix = '';
            
            if (hitTypes.length > 0) {
                // åªå–ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„å‘½ä¸­ç±»å‹
                const hitTypeId = hitTypes[0];
                hitRateInfo = getHitRateInfo(hitTypeId);
                
                if (hitRateInfo) {
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ å‘½ä¸­ç‡å‰ç¼€
                    const hitRates = hitRateInfo.hitRates;
                    if (hitRates.length === 1 && hitRates[0] !== 100) {
                        hitRatePrefix = `ä»¥ã€${hitRates[0]}%ã€‘å‘½ä¸­ç‡ï¼Œ`;
                    }
                }
            }
            
            // ç”Ÿæˆå€¼æ˜¾ç¤ºå­—ç¬¦ä¸²
            const valueDisplay = formatValueDisplay(effectiveValues);
            const ratioDisplay = formatValueDisplay(effectiveRatios);
            const turnDisplay = formatValueDisplay(effectiveTurns);
            const countDisplay = formatValueDisplay(effectiveCounts);
            
            // æ ¼å¼åŒ–æ¬¡æ•°æ˜¾ç¤ºï¼ˆè€ƒè™‘å‘½ä¸­ç‡ä¿¡æ¯ï¼‰
            const baseCount = countDisplay || count || 1;
            const formattedCount = hitRateInfo ? formatCountDisplay(baseCount, hitRateInfo) : baseCount;
            
            // åˆ¤æ–­æ•ˆæœç±»å‹
            const isDamage = effectiveValues.some(v => v !== 0);
            const hasAddAilment = addAilmentText.length > 0;
            const hasSubAilment = subAilmentText.length > 0;
            const hasTurns = effectiveTurns.length > 0;
            
            // ç”Ÿæˆæ•ˆæœæè¿°
            if (!isDamage && hasAddAilment && hasTurns) {
                // çº¯æ·»åŠ çŠ¶æ€æ•ˆæœ
                return `${hitRatePrefix}å¯¹ã€${target}ã€‘æ–½åŠ ã€${formattedCount}ã€‘æ¬¡ã€${turnDisplay}ã€‘å›åˆçš„ã€${addAilmentText}${addAilmentExtraInfo}ã€‘çŠ¶æ€ã€‚`;
                
            } else if (!isDamage && hasSubAilment) {
                // çº¯è§£é™¤çŠ¶æ€æ•ˆæœ
                return `å¯¹ã€${target}ã€‘è§£é™¤ã€${subAilmentText}${subAilmentExtraInfo}ã€‘çŠ¶æ€ã€‚`;
                
            } else if (isDamage && !hasAddAilment && !hasSubAilment) {
                // çº¯ä¼¤å®³/å›å¤æ•ˆæœ
                const damageType = getDamageType(avail.m_CalcType, avail.m_ModifyType, avail.m_ModifyStatus, effectiveValues[0], avail.m_OverrideWeapon, avail.m_OverrideMagic);
                const formula = simplifyDamageFormula(avail.m_CalcType, valueDisplay, ratioDisplay);
                
                // æ ¹æ®calcTypeå†³å®šæ˜¯å¦ç”Ÿæˆå¯ç‚¹å‡»é“¾æ¥
                let formulaDisplay = '';
                if (avail.m_CalcType === 1 || avail.m_CalcType === 2) {
                    formulaDisplay = `<a class="formula-link" data-calc-type="${avail.m_CalcType}" data-value="${valueDisplay}" data-ratio="${ratioDisplay}">${formula}</a>`;
                } else {
                    formulaDisplay = `<span>${formula}</span>`;
                }
                
                return `${hitRatePrefix}å¯¹ã€${target}ã€‘é€ æˆã€${formattedCount}ã€‘æ¬¡${formulaDisplay}çš„ã€${damageType}ã€‘`;
                
            } else if (isDamage && hasAddAilment && hasTurns && !hasSubAilment) {
                // ä¼¤å®³+æ·»åŠ çŠ¶æ€ç»„åˆ
                const damageType = getDamageType(avail.m_CalcType, avail.m_ModifyType, avail.m_ModifyStatus, effectiveValues[0], avail.m_OverrideWeapon, avail.m_OverrideMagic);
                const formula = simplifyDamageFormula(avail.m_CalcType, valueDisplay, ratioDisplay);
                
                // æ ¹æ®calcTypeå†³å®šæ˜¯å¦ç”Ÿæˆå¯ç‚¹å‡»é“¾æ¥
                let formulaDisplay = '';
                if (avail.m_CalcType === 1 || avail.m_CalcType === 2) {
                    formulaDisplay = `<a class="formula-link" data-calc-type="${avail.m_CalcType}" data-value="${valueDisplay}" data-ratio="${ratioDisplay}">${formula}</a>`;
                } else {
                    formulaDisplay = `<span>${formula}</span>`;
                }
                
                return `${hitRatePrefix}å¯¹ã€${target}ã€‘é€ æˆã€${formattedCount}ã€‘æ¬¡${formulaDisplay}çš„ã€${damageType}ã€‘ï¼Œå¹¶æ–½åŠ ã€${turnDisplay}ã€‘å›åˆçš„ã€${addAilmentText}${addAilmentExtraInfo}ã€‘çŠ¶æ€ã€‚`;
                
            } else if (isDamage && hasSubAilment) {
                // ä¼¤å®³+è§£é™¤çŠ¶æ€ç»„åˆ
                const damageType = getDamageType(avail.m_CalcType, avail.m_ModifyType, avail.m_ModifyStatus, effectiveValues[0], avail.m_OverrideWeapon, avail.m_OverrideMagic);
                const formula = simplifyDamageFormula(avail.m_CalcType, valueDisplay, ratioDisplay);
                
                // æ ¹æ®calcTypeå†³å®šæ˜¯å¦ç”Ÿæˆå¯ç‚¹å‡»é“¾æ¥
                let formulaDisplay = '';
                if (avail.m_CalcType === 1 || avail.m_CalcType === 2) {
                    formulaDisplay = `<a class="formula-link" data-calc-type="${avail.m_CalcType}" data-value="${valueDisplay}" data-ratio="${ratioDisplay}">${formula}</a>`;
                } else {
                    formulaDisplay = `<span>${formula}</span>`;
                }
                
                let result = `${hitRatePrefix}å¯¹ã€${target}ã€‘é€ æˆã€${formattedCount}ã€‘æ¬¡${formulaDisplay}çš„ã€${damageType}ã€‘`;
                
                if (hasAddAilment && hasTurns) {
                    result += `ï¼Œæ–½åŠ ã€${turnDisplay}ã€‘å›åˆçš„ã€${addAilmentText}${addAilmentExtraInfo}ã€‘çŠ¶æ€ï¼Œå¹¶è§£é™¤ã€${subAilmentText}${subAilmentExtraInfo}ã€‘çŠ¶æ€ã€‚`;
                } else {
                    result += `ï¼Œå¹¶è§£é™¤ã€${subAilmentText}ã€‘${subAilmentExtraInfo}çŠ¶æ€ã€‚`;
                }
                
                return result;
                
            } else {
                return '(æŠ€èƒ½æ•ˆæœè¯·å‚è§æè¿°)';
            }
        }

        // æ ¼å¼åŒ–å€¼æ˜¾ç¤º
        function formatValueDisplay(values) {
            if (!values || values.length === 0) return '';
            if (values.length === 1) return values[0];
            
            // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ç›¸åŒ
            const allSame = values.every(v => v === values[0]);
            if (allSame) return values[0];
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºç­‰å·®æ•°åˆ—
            const diff = values[1] - values[0];
            const isArithmetic = values.slice(1).every((v, i) => v - values[i] === diff);
            
            if (isArithmetic && diff !== 0) {
                return `${values[0]}[+${diff}/BP]`;
            } else {
                return `[${values.join('/')}]`;
            }
        }

        // è·å–ä¼¤å®³ç±»å‹
        function getDamageType(calcType, modifyType, modifyStatus, value, overrideWeapon, overrideMagic) {
            if (calcType === 1 && modifyType === 1 && modifyStatus === 5) {
                return value < 0 ? `ç‰©ç†${overrideWeapon > 0 ? "ï¼ˆ" + weaponIconMapping[overrideWeapon] + "ï¼‰" : ""}ä¼¤å®³` : 'HPå›å¤';
            } else if (calcType === 2 && modifyType === 1 && modifyStatus === 5) {
                return value < 0 ? `é­”æ³•${overrideMagic > 0 ? "ï¼ˆ" + magicIconMapping[overrideMagic] + "ï¼‰" : ""}ä¼¤å®³` : 'HPå›å¤';
            } else if (calcType === 3 && modifyType === 1 && modifyStatus === 5) {
                return value < 0 ? `æ¯”ä¾‹ä¼¤å®³` : 'HPå›å¤';
            } else if (calcType === 4 && modifyType === 1 && modifyStatus === 5) {
                return value < 0 ? `é“å…·ä¼¤å®³` : 'HPå›å¤';
            } else if (modifyType === 2) {
                if (modifyStatus === 5) return 'HPå›å¤';
                if (modifyStatus === 6) return 'SPå›å¤';
            } else if (modifyType === 26 && modifyStatus === 6) {
                return 'SPè¶…é‡å›å¤';
            } else if (modifyType === 1 && modifyStatus === 6) {
                return value < 0 ? 'SPä¼¤å®³' : 'SPå›å¤';
            } else if (modifyStatus === 7) {
                return value > 0 ? 'BPå¢åŠ ' : 'BPå‡å°‘';
            } else if (modifyType === 25) {
                return 'JPå¢åŠ ';
            } else if ([1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 18].includes(modifyStatus)) {
                const statusNames = {
                    1: 'æœ€å¤§HP', 2: 'æœ€å¤§SP', 9: 'ç‰©æ”»', 10: 'ç‰©é˜²',
                    11: 'é­”æ”»', 12: 'é­”é˜²', 13: 'é€Ÿåº¦', 14: 'æš´å‡»',
                    15: 'å‘½ä¸­', 16: 'å›é¿', 18: 'å¿…æ€æ§½'
                };
                return statusNames[modifyStatus] + (value > 0 ? 'å¢åŠ ' : 'å‡å°‘');
            }
            
            return 'æœªçŸ¥å±æ€§';
        }

        // ç”Ÿæˆä¼¤å®³å…¬å¼
        function generateDamageFormula(calcType, valueDisplay, ratioDisplay) {
            switch (calcType) {
                case 1:
                    return `(ç‰©æ”»*1.5*${Math.abs(valueDisplay)}/100-ç‰©é˜²)*(${ratioDisplay}/100)*å…¶ä»–å€ç‡`;
                case 2:
                    const absValue = Math.abs(valueDisplay);
                    if (valueDisplay < 0) {
                        return `(é­”æ”»*1.5*${absValue}/100-é­”é˜²)*(${ratioDisplay}/100)*å…¶ä»–å€ç‡`;
                    } else {
                        return `(é­”é˜²*1.5*${absValue}/100)*(${ratioDisplay}/100)*å…¶ä»–å€ç‡`;
                    }
                case 3:
                    if (ratioDisplay === 100) {
                        return `ä¼¤å®³å€¼*${valueDisplay}%`;
                    } else {
                        return `è‡ªä½™å€¼*${valueDisplay}%*${ratioDisplay}%`;
                    }
                case 4:
                    const strDisplay = typeof valueDisplay === 'number' ? Math.abs(valueDisplay) : valueDisplay;
                    return `${strDisplay}ç‚¹`;
                default:
                    return `æœªçŸ¥è®¡ç®—å…¬å¼(ç±»å‹${calcType})`;
            }
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            resultsDiv.innerHTML = `<div class="error-message">${message}</div>`;
        }

        // æ˜¾ç¤ºæœç´¢ç»“æœ
        function displayResults(results) {
            if (results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>æœªæ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½</h3>
                        <p>è¯·å°è¯•å…¶ä»–å…³é”®è¯è¿›è¡Œæœç´¢</p>
                    </div>
                `;
                return;
            }
            
            let html = `<div class="result-count">æ‰¾åˆ° ${results.length} ä¸ªåŒ¹é…çš„æŠ€èƒ½</div>`;
            
            for (const result of results) {
                const skill = result.skill;
                const skillInfo = extractSkillInfo(skill);
                const skillEffects = generateSkillEffects(skill);
                
                // æ ¼å¼åŒ–åŒ¹é…åº¦æ˜¾ç¤º
                const matchPercent = Math.round(result.matchScore * 100);
                let matchClass = 'high';
                if (matchPercent < 80) matchClass = 'medium';
                if (matchPercent < 75) matchClass = '';
                
                html += `
                    <div class="skill-card">
                        <div class="skill-header">
                            <div>
                                <div class="skill-name">
                                    ${skillInfo.displayName || skillInfo.name || 'æœªçŸ¥æŠ€èƒ½'}
                                    <span class="match-rate ${matchClass}">${matchPercent}%åŒ¹é…</span>
                                </div>
                            </div>
                            <div class="skill-id">ID: ${skill.m_id}</div>
                        </div>
                        
                        <div class="skill-description">
                            ${skillInfo.description || 'æ— æè¿°'}
                        </div>
                        
                        <div class="skill-info">
                            <div class="info-item">
                                <div class="info-label">å±æ€§</div>
                                <div class="info-value">${skillInfo.attributes}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">æŠ€èƒ½ç±»å‹</div>
                                <div class="info-value">${skillInfo.category}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">SPæ¶ˆè€—</div>
                                <div class="info-value">${skillInfo.spCost}</div>
                            </div>
                            ${skillInfo.coolDown ? `
                            <div class="info-item">
                                <div class="info-label">å†·å´</div>
                                <div class="info-value">${skillInfo.coolDown}å›åˆ</div>
                            </div>` : ''}
                            ${skillInfo.critRate ? `
                            <div class="info-item">
                                <div class="info-label">æš´å‡»è¡¥æ­£</div>
                                <div class="info-value">${skillInfo.critRate}%</div>
                            </div>` : ''}
                            ${skillInfo.shieldDamage ? `
                            <div class="info-item">
                                <div class="info-label">ç ´ç›¾å±‚æ•°</div>
                                <div class="info-value">${skillInfo.shieldDamage}</div>
                            </div>` : ''}
                            ${skillInfo.ownerInfo && skillInfo.ownerInfo.owner && skillInfo.ownerInfo.canEssential !== null ? `
                            <div class="info-item">
                                <div class="info-label">ç²¾ç²¹åŒ–</div>
                                <div class="info-value">${skillInfo.ownerInfo.canEssential ? 'å¯ç²¾ç²¹åŒ–' : 'ä¸å¯ç²¾ç²¹åŒ–'}</div>
                            </div>` : ''}
                        </div>
                        
                        <div class="effect-details">
                            <div class="effect-header">æŠ€èƒ½æ•ˆæœ</div>
                            ${skillEffects.map(effect => `
                                <div class="effect-item">${effect}</div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = html;
            
            // ç»‘å®šä¼¤å®³è®¡ç®—å™¨é“¾æ¥äº‹ä»¶
            document.querySelectorAll('.formula-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const calcType = parseInt(this.getAttribute('data-calc-type'));
                    const valueDisplay = this.getAttribute('data-value');
                    const ratioDisplay = this.getAttribute('data-ratio');
                    
                    // å°è¯•è§£ææ•°å€¼
                    let valueNum, ratioNum;
                    
                    // è§£ævalue
                    if (valueDisplay.includes('[') && valueDisplay.includes(']')) {
                        valueNum = valueDisplay; // ä¿æŒå­—ç¬¦ä¸²æ ¼å¼
                    } else {
                        valueNum = parseFloat(valueDisplay);
                        if (isNaN(valueNum)) valueNum = valueDisplay;
                    }
                    
                    // è§£æratio
                    if (ratioDisplay.includes('[') && ratioDisplay.includes(']')) {
                        ratioNum = ratioDisplay; // ä¿æŒå­—ç¬¦ä¸²æ ¼å¼
                    } else {
                        ratioNum = parseFloat(ratioDisplay);
                        if (isNaN(ratioNum)) ratioNum = ratioDisplay;
                    }
                    
                    showDamageCalculator(calcType, valueNum, ratioNum, this);
                });
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–çŠ¶æ€æŒ‡ç¤ºå™¨
            initStatusIndicators();
            
            // åŠ è½½æ•°æ®
            loadAllData();
            
            // ç›‘å¬æœç´¢æŒ‰é’®ç‚¹å‡»
            searchBtn.addEventListener('click', searchSkills);
            
            // æ”¯æŒæŒ‰Enteré”®è¿›è¡ŒæŸ¥è¯¢
            searchInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter' && !searchBtn.disabled) {
                    searchSkills();
                }
            });
            
            // å…³é—­è®¡ç®—å™¨
            closeCalculator.addEventListener('click', function() {
                damageCalculator.style.display = 'none';
                calculatorVisible = false;
                currentLinkElement = null;
            });
            
            // ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼Œæ›´æ–°è®¡ç®—å™¨ä½ç½®
            window.addEventListener('scroll', function() {
                updateCalculatorPosition();
            });
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œæ›´æ–°è®¡ç®—å™¨ä½ç½®
            window.addEventListener('resize', function() {
                updateCalculatorPosition();
            });
        });
    </script>
</body>
</html>